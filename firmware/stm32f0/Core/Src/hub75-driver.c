/*
 * hub75-driver.c
 *
 *  Created on: Jan 26, 2024
 *      Author: lemck
 */

#include "hub75-driver.h"
#include "tim.h"

#define NUM_WRITE_CYCLES    6
#define MAX_SCAN_ROWS       16
#define BYTES_PER_ROW       8
#define NUM_COLOUR_LINES    3
#define ROW_BUFFER_SIZE     BYTES_PER_ROW*NUM_COLOUR_LINES*2


static SPI_HandleTypeDef *hspi;

static uint8_t bitmap[] = {
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
};
static uint8_t zeros[] =
{
        0,0,0,0,0,0,0,0
};
static uint8_t row_buffer[ROW_BUFFER_SIZE];

static uint8_t row_id = 11;
static Colours row_colour = Yellow;

static void write_row(uint8_t row_num);

static inline void set_row_address(uint8_t row_num);
static inline void set_latch(void);
static inline void reset_latch(void);

void HUB75_Init(SPI_HandleTypeDef *spi)
{
    hspi = spi;
    for (int i=0; i<12; i++)
    {
        HAL_GPIO_WritePin(DISP_LAT_GPIO_Port, DISP_LAT_Pin, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(DISP_OE_GPIO_Port, DISP_OE_Pin, GPIO_PIN_RESET);
        HAL_SPI_Transmit(hspi, zeros, 8, 500);
        HAL_GPIO_WritePin(DISP_LAT_GPIO_Port, DISP_LAT_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(DISP_OE_GPIO_Port, DISP_OE_Pin, GPIO_PIN_SET);
    }
    HAL_GPIO_WritePin(DISP_LAT_GPIO_Port, DISP_LAT_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(DISP_OE_GPIO_Port, DISP_OE_Pin, GPIO_PIN_RESET);
}

void HUB75_Start(void)
{
    HAL_TIM_Base_Start_IT(&htim7);
}

void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
    set_latch();
    row_id = (row_id + 1) % MAX_SCAN_ROWS;
    HAL_TIM_Base_Start_IT(&htim7);
}

void HUB75_TimerCallback(void)
{
    HAL_TIM_Base_Stop(&htim7);
    reset_latch();
    set_row_address(row_id);
    write_row(row_id);
}

inline void set_row_address(uint8_t row_num)
{
    HAL_GPIO_WritePin(DISP_A_GPIO_Port, DISP_A_Pin, row_num & (1<<0));
    HAL_GPIO_WritePin(DISP_B_GPIO_Port, DISP_B_Pin, row_num & (1<<1));
    HAL_GPIO_WritePin(DISP_C_GPIO_Port, DISP_C_Pin, row_num & (1<<2));
    HAL_GPIO_WritePin(DISP_D_GPIO_Port, DISP_D_Pin, row_num & (1<<3));
    HAL_GPIO_WritePin(DISP_E_GPIO_Port, DISP_E_Pin, 1);
}

inline void reset_latch(void)
{
    HAL_GPIO_WritePin(DISP_LAT_GPIO_Port, DISP_LAT_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(DISP_OE_GPIO_Port, DISP_OE_Pin, GPIO_PIN_SET);
}

inline void set_latch(void)
{
    HAL_GPIO_WritePin(DISP_LAT_GPIO_Port, DISP_LAT_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(DISP_OE_GPIO_Port, DISP_OE_Pin, GPIO_PIN_RESET);
}

void write_row(uint8_t row_num)
{
    uint8_t *data_pointer = bitmap + row_num*BYTES_PER_ROW;
    for (int i=0; i<NUM_COLOUR_LINES; i++)
    {
        if (row_colour & (1<<i))
        {
            memcpy(row_buffer + i*BYTES_PER_ROW, data_pointer + MAX_SCAN_ROWS*BYTES_PER_ROW, BYTES_PER_ROW);
        }
        else
        {
            memset(row_buffer + i*BYTES_PER_ROW, 0, BYTES_PER_ROW);
        }
    }
    for (int i=0; i<NUM_COLOUR_LINES; i++)
    {
        if (row_colour & (1<<i))
        {
            memcpy(row_buffer + i*BYTES_PER_ROW + ROW_BUFFER_SIZE/2, data_pointer, BYTES_PER_ROW);
        }
        else
        {
            memset(row_buffer + i*BYTES_PER_ROW + ROW_BUFFER_SIZE/2, 0, BYTES_PER_ROW);
        }
    }
    HAL_SPI_Transmit_IT(hspi, row_buffer, ROW_BUFFER_SIZE);
}
